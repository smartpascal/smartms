<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>Test test test</title>
		<meta charset="utf-8">

		<style type="text/css">
			body {
				background-color: #0072bc;
				margin: 0px;
				overflow: hidden;
			}
		</style>

	</head>
	<body>

	<button id="dis" onclick="new bitmapText(document.getElementById('image1'),'sigmarone', 'Bitmap Fonts!', 100, 100, 1, 0, 0); return false;">Click me</button>
<!--<canvas id='onScreen'></canvas>-->

<!--<script type="text/javascript" src="fontloader.js"></script>-->
<script>		

function Fontsheet(imageFilename, metricsFilename, kerning, frame) {
	this.imageFilename = imageFilename;
	this.metricsFilename = metricsFilename;
	this.kerning = kerning || 0;
	this.fontsheetImage = new Image();
	this.spriteArray = [];
	this.data = {};

}

Fontsheet.prototype.loadXMLFontsheet = function (font, txt, scale) {
	this.fontsheetImage.src = this.imageFilename;
	this.data.chars = {};

	var destX = 0;
	var xmlDoc = loadXMLDoc(this.metricsFilename);
	var info = xmlDoc.getElementsByTagName('info')[0];
	var common = xmlDoc.getElementsByTagName('common')[0];

	this.data.font = info.getAttribute('face');
	this.data.size = parseInt(info.getAttribute('size'), 10);
	this.data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) + 0; //ySpacing};

	var x = (this.frame) ? this.frame.x : 0;
	var y = (this.frame) ? this.frame.y : 0;

	var letters = xmlDoc.getElementsByTagName("character");
	for (var i = 0; i < letters.length; i++) {
		var charCode = txt.charCodeAt(i) -32;
		//var charCode = parseInt(letters.id, 10);
		if (i < txt.length) {
			this.spriteArray[i] = {
				x : x + parseInt(letters[charCode].getAttribute('x'), 10),
				y : y + parseInt(letters[charCode].getAttribute('y'), 10),
				width : parseInt(letters[charCode].getAttribute('width'), 10),
				height : parseInt(letters[charCode].getAttribute('height'), 10),
				xoffset : parseInt(letters[charCode].getAttribute('xoffset'), 10) / 1,
				yoffset : parseInt(letters[charCode].getAttribute('yoffset'), 10) / 1,
				xadvance : (parseInt(letters[charCode].getAttribute('xadvance'), 10) + 1) / 1
			};
			// Move the position for drawing the next character
			destX += this.spriteArray[i].xadvance;
		}
	}
	this.data.lineWidth = (destX + this.kerning + 10) * scale;
	this.data.chars = this.spriteArray;

	return this.data;
	//return this.finalizeBitmapFont(this.data);
};

Fontsheet.prototype.loadJSONFontsheet = function (font, txt, scale) {
	var json;
	this.fontsheetImage.src = this.imageFilename;
	//this.data.chars = {};

	var destX = 0;
	//var xmlDoc = loadXMLDoc(this.metricsFilename);
	//var info = xmlDoc.getElementsByTagName('info')[0];
	//var common = xmlDoc.getElementsByTagName('common')[0];

	//this.data.font = info.getAttribute('face');
	//this.data.size = parseInt(info.getAttribute('size'), 10);
	//this.data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) + 0; //ySpacing};
	
	 loadJSON(this.metricsFilename, function(response) {
	  // Parse JSON string into object
		json = JSON.parse(response);

	 });
	 
	var data = {
	  font: json.face,
	  size: parseInt(json.size, 10),
	  lineHeight: parseInt(json.lineHeight, 10) + 0,  //ySpacing,
	  chars: {}
	};

	var x = (this.frame) ? this.frame.x : 0;
	var y = (this.frame) ? this.frame.y : 0;

	//var letters = xmlDoc.getElementsByTagName("character");
	var letters = json.chars;
	
	/*
	json.chars.forEach(

		function parseChar(letters, i) {
			console.log(i);
			//var charCode = parseInt(letters.id, 10);
			//var charCode = txt.charCodeAt(i) - 32;
			/*this.spriteArray[i] = {
				x : x + parseInt(letters[charCode].x, 10),
				y : y + parseInt(letters[charCode].y, 10),
				width : parseInt(letters[charCode].width, 10),
				height : parseInt(letters[charCode].height, 10),
				xoffset : parseInt(letters[charCode].xoffset, 10) / 1,
				yoffset : parseInt(letters[charCode].yoffset, 10) / 1,
				xadvance : (parseInt(letters[charCode].xadvance, 10) + 1) / 1
			};
			// Move the position for drawing the next character
			destX += this.spriteArray[i].xadvance;
		}

	);
	*/
	
	
	for (var i = 0; i < letters.length; i++) {
		var charCode = txt.charCodeAt(i) - 32;
		//var charCode = parseInt(letters.id, 10);
		if (i < txt.length) {
			this.spriteArray[i] = {
				x : x + parseInt(letters[charCode].x, 10),
				y : y + parseInt(letters[charCode].y, 10),
				width : parseInt(letters[charCode].width, 10),
				height : parseInt(letters[charCode].height, 10),
				xoffset : parseInt(letters[charCode].xoffset, 10) / 1,
				yoffset : parseInt(letters[charCode].yoffset, 10) / 1,
				xadvance : (parseInt(letters[charCode].xadvance, 10) + 1) / 1
			};
			// Move the position for drawing the next character
			destX += this.spriteArray[i].xadvance;
		}
	}
	
	data.lineWidth = (destX + this.kerning + 10) * scale;
	data.chars = this.spriteArray;

	return data;
};


function loadJSON(file, callback){
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function(){
        if(xhr.readyState === 4 && xhr.status === 200){
            // Required use of an anonymous callback 
            // as .open() will NOT return a value but simply returns undefined in asynchronous mode			
            callback(xhr.responseText);
        }
    }
	xhr.overrideMimeType("application/json");
    xhr.open('GET', file, false);
    xhr.send(null);
}

function loadXMLDoc(dname) {
	var xhttp;
	if (window.XMLHttpRequest) {
		xhttp = new XMLHttpRequest();
	} else {
		xhttp = new ActiveXObject("Microsoft.XMLHTTP");
	}
	xhttp.open("GET", dname, false);
	xhttp.send();
	
	return xhttp.responseXML;
}

function loadImage(file, callback){
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function(){
        if(xhr.readyState === 4 && xhr.status === 200){
            // Required use of an anonymous callback 
            // as .open() will NOT return a value but simply returns undefined in asynchronous mode			
            callback(xhr.responseText);
        }
    }
	xhr.overrideMimeType("image/x-png");
    xhr.open('GET', file, false);
    xhr.send(null);
}

/*
function sortByKey(array, key) {
    return array.sort(function(a, b) {
        var x = a[key]; var y = b[key];
        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
    });
}

JSON.stringify( sortByKey(chars, 'id') )
*/

function bitmapText(parent, font, txt, x, y, scale, kerning, frame) {
    //font = font || '';
	this.txt = txt || "";
	this.scale = scale || 1;
	this.kerning = kerning || 0;
	this.frame = frame || 0;
	
	function criarOffscreenCanvas(width, height) {
		var canvas = document.createElement('canvas');
		canvas.width = width;
		canvas.height = height;
		return canvas;
	}

	function createOffscreenCanvas(width, height) {
		var destW = 0;
		var i,
		srcX,
		srcY,
		srcW,
		srcH,
		srcOffsetY,
		srcOffsetX,
		xAdvance;

		var offScreenCanvas = criarOffscreenCanvas(width, height);
		var ctx = offScreenCanvas.getContext("2d");
		ctx.scale(scale, scale);

		for (i = 0; i < txt.length; i++) {
			// Retrieve font's metadata
			srcX = parseInt(bitmapFont[i].x);
			srcY = parseInt(bitmapFont[i].y);
			srcW = parseInt(bitmapFont[i].width);
			srcH = parseInt(bitmapFont[i].height);
			srcOffsetX = parseInt(bitmapFont[i].xoffset);
			srcOffsetY = parseInt(bitmapFont[i].yoffset);
			xAdvance = parseInt(bitmapFont[i].xadvance);

			// Draw the character on the label's surface
			ctx.drawImage(myFontsheet.fontsheetImage,
				// src
				srcX, srcY, srcW, srcH,
				// dest
				destW + srcOffsetX, srcOffsetY, srcW, srcH);

			// Move the position for drawing the next character
			destW += xAdvance;
		}
		return offScreenCanvas;
	}

	function copyToOnScreen(offScreenCanvas) {
	  var offScreenContext = offScreenCanvas.getContext('2d');
	  return offScreenContext.canvas.toDataURL('image/png');
	}
	
	/* entry point */

    var myFontsheet = new Fontsheet("fonts/"+font+".png", "fonts/"+font+".xml", kerning, frame);
	var obj = myFontsheet.loadXMLFontsheet(font, txt, scale);
	var fontHeight = obj.lineHeight;
	var fontWidth = obj.lineWidth;
	var bitmapFont = obj.chars;

	/*
	setTimeout(function(){
		var docFragment = ( document.createDocumentFragment() ); // contains all gathered nodes

		var div_ = ( document.createElement('IMG') );
		div_.setAttribute("id", 'image1');
		div_.setAttribute("src", copyToOnScreen(createOffscreenCanvas(fontWidth, (fontHeight) * scale)) );
		div_.setAttribute("style", "position:absolute; left:" + x + "px; top:" + y + "px;");	  
		docFragment.appendChild(div_);
		
		//document.body.appendChild( docFragment );	
		document.getElementById("image1").appendChild( docFragment );
	},0);
	*/

	setTimeout(function(){
	
		//document.getElementById("image1").src = copyToOnScreen(createOffscreenCanvas(fontWidth, (fontHeight) * scale));
		parent.setAttribute("style", "position:absolute; left:" + x + "px; top:" + y + "px;");
		//parent.setAttribute("crossOrigin","Anonymous");
		parent.src = copyToOnScreen(createOffscreenCanvas(fontWidth, (fontHeight) * scale));
	},0);
	
	  
	//console.log(testeImage);  
	  //img.src = copyToOnScreen(createOffscreenCanvas(fontWidth, (fontHeight) * scale));
	  //img.setAttribute("style", "position:absolute; left:" + x + "px; top:" + y + "px;");
	  //document.body.appendChild(img);
	//},0);
/*
	if (testImage) {
  	  document.getElementById("image1").appendChild(testImage);
	}
	*/
}

function criarImage(x, y, font, text){
		var docFragment = ( document.createDocumentFragment() ); // contains all gathered nodes

		var div_ = ( document.createElement('DIV') );
		//div_.setAttribute("class", "spinner");
		docFragment.appendChild(div_);


		var div_0 = document.createElement('IMG');
		div_0.setAttribute("id", 'image1');
		//div_0.setAttribute("src", dataURL );
		//div_0.setAttribute("src", copyToOnScreen(createOffscreenCanvas(fontWidth, (fontHeight) * scale)) );
		
		div_0.setAttribute("src", (new bitmapText(font, text, x, y, 1, 0, 0))() );
		div_0.setAttribute("style", "position:absolute; left:" + x + "px; top:" + y + "px;");	  
		div_.appendChild(div_0);
		
		document.body.appendChild( docFragment );	
}
		
		

		var docFragment = ( document.createDocumentFragment() ); // contains all gathered nodes

		var div_ = ( document.createElement('IMG') );
		div_.setAttribute("id", 'image1');
		div_.setAttribute("crossOrigin","Anonymous");
		docFragment.appendChild(div_);
	
		document.body.appendChild( docFragment );	
		console.log('111');

//var t = new bitmapText('sigmarone', 'Bitmap Fonts!', 100, 100, 1, 0, 0);
//document.getElementById("image1").appendChild(t);




function teste(){
/*
var arr = ["SkranjiBold40","carrierCommand","desyrelpink","FascinateInline","fontGeneric","LuckiestGuy","nokia16black",
           "Orbitron","PermanentMarker","Sarina","shortStack","atari","desyrel1x","desyrel2x","desyrel",
		   "font1x","font2x","font3x","nokia16","nokia","sigmarone"];
		   
    arr.forEach(
		function parseChar(font, i) {
			//console.log(i);
			new bitmapText(font, 'Bitmap Fonts!', 0, i*100, 1, 0, 0);
			
		}
	);
*/	
//DOES WORKING: desyrelpink, FascinateInline, LuckiestGuy, nokia16black, Orbitron, PermanentMarker, Sarina, desyrel1x, desyrel2x, desyrel, nokia16, nokia, sigmarone, atari, SkranjiBold40, carrierCommand, fontGeneric, shortStack, font1x, font2x, font3x 
new bitmapText('atari', 'abcd', 100, 0, 1, 0, 0);
//new bitmapText('Desyrel', 'Bitmap Fonts!', 100, 100, 1, 0, 0);
//new bitmapText('Sarina', 'Bitmap Fonts!', 100, 200, 0.5, 0, 0);

}

/*
var xml = (function(){

	(function CarregaImg(){
	  loadImage('fonts/sigmarone.png', function(){});
	  loadImage('fonts/Desyrel.png', function(){});
	})();
	
    return {
        sigmarone: loadXMLDoc('fonts/sigmarone.xml'),
        DesyRel: loadXMLDoc('fonts/Desyrel.xml')
    }

})();
*/


</script>	

	</body>
</html>
