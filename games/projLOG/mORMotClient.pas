/// remote access to a mORMot server using SmartMobileStudio
// - retrieved from http://localhost:8080/root/wrapper/SmartMobileStudio/mORMotClient.pas
// at 2016-10-27 14:23:01 using "SmartMobileStudio.pas.mustache" template
unit mORMotClient;

{
  WARNING:
    This unit has been generated by a mORMot 1.18.2934 server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) 2016 Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit would work on Smart Mobile Studio 2.1.1 and later.
}

interface

uses
  SmartCL.System,
  System.Types,
  SynCrossPlatformSpecific,
  SynCrossPlatformREST;


type // define some enumeration types, used below
  TMyRemoteSQLEngine = (rseOleDB, rseODBC, rseOracle, rseSQlite3, rseJet, rseMSSQL);

type // define some record types, used as properties below
  TTagList = record
    base: String;
    age: Integer;
    L: array of record
      fname: String;
      fsize: Integer;
    end;
  end;

type // define some dynamic array types, used as properties below
  TRawUTF8DynArray = array of RawUTF8;

type
  /// map "MyAuthUser" table
  TSQLMyAuthUser = class(TSQLRecord)
  protected
    fLogonName: String; 
    fDisplayName: String; 
    fPasswordHashHexa: String; 
    fGroupRights: TID; 
    fData: TSQLRawBlob; 
    fLastChange: TModTime; 
    fCreatedAt: TCreateTime; 
    fCreated: TDateTime; 
    fEmail: String; 
    fFirstName: String; 
    fLastName: String; 
    fValidTill: TDateTime; 
    fConfirm_code: String; 
    fpwd_reset_hash: String; 
    ftime_expired: TTimeLog; 
    // those overridden methods will emulate the needed RTTI
    class function ComputeRTTI: TRTTIPropInfos; override;
    procedure SetProperty(FieldIndex: integer; const Value: variant); override;
    function GetProperty(FieldIndex: integer): variant; override;
  public
    property LogonName: String read fLogonName write fLogonName;
    property DisplayName: String read fDisplayName write fDisplayName;
    property PasswordHashHexa: String read fPasswordHashHexa write fPasswordHashHexa;
    // defined as GroupRights: TSQLAuthGroup on the server
    property GroupRights: TID read fGroupRights write fGroupRights;
    property Data: TSQLRawBlob read fData write fData;
    property LastChange: TModTime read fLastChange write fLastChange;
    property CreatedAt: TCreateTime read fCreatedAt write fCreatedAt;
    property Created: TDateTime read fCreated write fCreated;
    property Email: String read fEmail write fEmail;
    property FirstName: String read fFirstName write fFirstName;
    property LastName: String read fLastName write fLastName;
    property ValidTill: TDateTime read fValidTill write fValidTill;
    property Confirm_code: String read fConfirm_code write fConfirm_code;
    property pwd_reset_hash: String read fpwd_reset_hash write fpwd_reset_hash;
    property time_expired: TTimeLog read ftime_expired write ftime_expired;
  end;
  
  /// map "SampleRecord" table
  TSQLSampleRecord = class(TSQLRecord)
  protected
    fTime: TModTime; 
    fName: String; 
    fQuestion: String; 
    // those overridden methods will emulate the needed RTTI
    class function ComputeRTTI: TRTTIPropInfos; override;
    procedure SetProperty(FieldIndex: integer; const Value: variant); override;
    function GetProperty(FieldIndex: integer): variant; override;
  public
    property Time: TModTime read fTime write fTime;
    property Name: String read fName write fName;
    property Question: String read fQuestion write fQuestion;
  end;
  
  /// service accessible via http://localhost:8080/root/MyService
  // - this service will run in sicShared mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  TServiceMyService = class(TServiceClientAbstract)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TSQLRestClientURI); override;

    procedure Add(n1: Integer; n2: Integer; 
      onSuccess: procedure(Result: Integer); onError: TSQLRestEvent);
    function _Add(const n1: Integer; const n2: Integer): Integer;

    procedure GetSampleRecord(id: TID; 
      onSuccess: procedure(SampleRecord: TSQLSampleRecord; Result: Boolean); onError: TSQLRestEvent);
    function _GetSampleRecord(const id: TID; var SampleRecord: TSQLSampleRecord): Boolean;

    procedure SignIn(userPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _SignIn(const userPass: String): Variant;

    procedure ChangePassword(newUser: String; oldPass: String; newPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _ChangePassword(const newUser: String; const oldPass: String; const newPass: String): Variant;

    procedure MostraRec(
      onSuccess: procedure(output: Variant); onError: TSQLRestEvent);
    procedure _MostraRec(var output: Variant);

    procedure MostraCustomRec(
      onSuccess: procedure(Result: THttpBody); onError: TSQLRestEvent);
    function _MostraCustomRec(): THttpBody;

    procedure MostraOtherRec(
      onSuccess: procedure(Result: THttpBody); onError: TSQLRestEvent);
    function _MostraOtherRec(): THttpBody;
  end;

  /// service accessible via http://localhost:8080/root/MyServiceFree
  // - this service will run in sicShared mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  TServiceMyServiceFree = class(TServiceClientAbstract)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TSQLRestClientURI); override;

    procedure listar(
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _listar(): Variant;

    procedure list(tag: String; tagList: TTagList; 
      onSuccess: procedure(tagList: TTagList; Result: String); onError: TSQLRestEvent);
    function _list(const tag: String; var tagList: TTagList): String;

    procedure decryptAES(cipherText: String; 
      onSuccess: procedure(Result: String); onError: TSQLRestEvent);
    function _decryptAES(const cipherText: String): String;

    procedure Echo(str: String; 
      onSuccess: procedure(Result: String); onError: TSQLRestEvent);
    function _Echo(const str: String): String;

    procedure genIV(
      onSuccess: procedure(Result: String); onError: TSQLRestEvent);
    function _genIV(): String;

    procedure RegisterCode(token: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _RegisterCode(const token: String): Variant;

    procedure RegisterConfirm(token: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _RegisterConfirm(const token: String): Variant;

    procedure SignUp(userPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _SignUp(const userPass: String): Variant;

    procedure ChangePassword(newUser: String; oldPass: String; newPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _ChangePassword(const newUser: String; const oldPass: String; const newPass: String): Variant;

    procedure ResetCode(userEmail: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _ResetCode(const userEmail: String): Variant;

    procedure ResetPassword(resetCode: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _ResetPassword(const resetCode: String): Variant;
  end;

  /// service accessible via http://localhost:8080/root/MyComplexNumber
  // - this service will run in sicShared mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  TServiceMyComplexNumber = class(TServiceClientAbstract)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TSQLRestClientURI); override;

    procedure Assign(aReal: Double; aImaginary: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
    procedure _Assign(const aReal: Double; const aImaginary: Double);

    procedure GetImaginary(
      onSuccess: procedure(Result: Double); onError: TSQLRestEvent);
    function _GetImaginary(): Double;

    procedure GetReal(
      onSuccess: procedure(Result: Double); onError: TSQLRestEvent);
    function _GetReal(): Double;

    procedure SetImaginary(Value: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
    procedure _SetImaginary(const Value: Double);

    procedure SetReal(Value: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
    procedure _SetReal(const Value: Double);

    procedure Add(aReal: Double; aImaginary: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
    procedure _Add(const aReal: Double; const aImaginary: Double);
  end;

  /// service accessible via http://localhost:8080/root/MyJogo
  // - this service will run in sicShared mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  TServiceMyJogo = class(TServiceClientAbstract)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TSQLRestClientURI); override;

    procedure PlayCard(
      onSuccess: procedure(Result: THttpBody); onError: TSQLRestEvent);
    function _PlayCard(): THttpBody;
  end;

  /// service accessible via http://localhost:8080/root/MyRemoteSQL
  // - this service will run in sicClientDriven mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  // - you should call explicitly Free to release the server instance
  TServiceMyRemoteSQL = class(TServiceClientAbstractClientDriven)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TSQLRestClientURI); override;

    procedure Connect(aEngine: TMyRemoteSQLEngine; aServerName: String; aDatabaseName: String; aUserID: String; aPassWord: String; 
      onSuccess: procedure(); onError: TSQLRestEvent);
    procedure _Connect(const aEngine: TMyRemoteSQLEngine; const aServerName: String; const aDatabaseName: String; const aUserID: String; const aPassWord: String);

    procedure GetTableNames(
      onSuccess: procedure(Result: TRawUTF8DynArray); onError: TSQLRestEvent);
    function _GetTableNames(): TRawUTF8DynArray;

    procedure Execute(aSQL: String; aExpectResults: Boolean; aExpanded: Boolean; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
    function _Execute(const aSQL: String; const aExpectResults: Boolean; const aExpanded: Boolean): Variant;
  end;


const
  /// the server port, corresponding to http://localhost:8080
  SERVER_PORT = 8080;
  /// the server model root name, corresponding to http://localhost:8080/root
  SERVER_ROOT = 'root';


/// return the database Model corresponding to this server
function GetModel(aRoot: string=SERVER_ROOT): TSQLModel;

/// create a TSQLRestClientHTTP instance and connect to the server
// - it will use by default port 8080 over root 'root', corresponding
// to http://localhost:8080/root
// - secure connection will be established via TSQLRestServerAuthenticationDefault
// with the supplied credentials
// - request will be asynchronous, and trigger onSuccess or onError event
procedure GetClient(const aServerAddress, aUserName,aPassword: string;
  onSuccess, onError: TSQLRestEvent;
  aServerPort: integer=SERVER_PORT; aServerRoot: string=SERVER_ROOT;
  aHttps: boolean=false);

// publish some low-level helpers for variant conversion
// - used internally: you should not need those functions in your end-user code
function Variant2TMyRemoteSQLEngine(const _variant: variant): TMyRemoteSQLEngine;
function TMyRemoteSQLEngineToText(const value: TMyRemoteSQLEngine): string;
function Variant2TTagList(const Value: variant): TTagList;
function TTagList2Variant(const Value: TTagList): variant;
function Variant2TRawUTF8DynArray(const _variant: variant): TRawUTF8DynArray;
function TRawUTF8DynArray2Variant(const _array: TRawUTF8DynArray): variant;


implementation


{ Some helpers for enumerates types }

{$HINTS OFF} // for begin asm return ... end; end below

// those functions will use the existing generated string array constant
// defined by the SMS compiler for each enumeration

function Variant2TMyRemoteSQLEngine(const _variant: variant): TMyRemoteSQLEngine;
begin
  asm return @VariantToEnum(@_variant,@TMyRemoteSQLEngine); end;
end;

function TMyRemoteSQLEngineToText(const value: TMyRemoteSQLEngine): string;
begin
  asm return @TMyRemoteSQLEngine[@value]; end;
end;

{$HINTS ON}

{ Some helpers for record types:
  due to potential obfuscation of generated JavaScript, we can't assume
  that the JSON used for transmission would match record fields naming }

function Variant2TTagList(const Value: variant): TTagList;
begin
  result.base := Value.base;
  result.age := Value.age;
  if VariantType(Value.L)=jvArray then begin
    var tmp: TTagList;
    tmp.L.SetLength(1);
    for var n := 0 to integer(Value.L.length)-1 do begin
      var source := Value.L[n];
      var dest := tmp.L[0];
      dest.fname := source.fname;
      dest.fsize := source.fsize;
      result.L.Add(dest);
    end;
  end;
end;

function TTagList2Variant(const Value: TTagList): variant;
begin
  result := new JObject;
  result.base := Value.base;
  result.age := Value.age;
  result.L := TVariant.CreateArray;
  for var source in Value.L do begin
    var dest: variant := new JObject;
    dest.fname := source.fname;
    dest.fsize := source.fsize;
    result.L.push(dest);
  end;
end;


{ Some helpers for dynamic array types }

function Variant2TRawUTF8DynArray(const _variant: variant): TRawUTF8DynArray;
var tmp: RawUTF8;
begin
  if VariantType(_variant)=jvArray then
    for var i := 0 to integer(_variant.Length)-1 do begin
      tmp := (_variant[i]);
      result.Add(tmp);
    end;
end;

function TRawUTF8DynArray2Variant(const _array: TRawUTF8DynArray): variant;
var i: integer;
begin
  result := TVariant.CreateArray;
  for i := 0 to high(_array) do
    result.push((_array[i]));
end;





{ TSQLMyAuthUser }

class function TSQLMyAuthUser.ComputeRTTI: TRTTIPropInfos;
begin
  result := TRTTIPropInfos.Create(
    ['LogonName','DisplayName','PasswordHashHexa','GroupRights','Data','LastChange','CreatedAt','Created','Email','FirstName','LastName','ValidTill','Confirm_code','pwd_reset_hash','time_expired'],
    [sftUnspecified,sftUnspecified,sftUnspecified,sftUnspecified,sftBlob,sftModTime,sftCreateTime,sftDateTime,sftUnspecified,sftUnspecified,sftUnspecified,sftDateTime,sftUnspecified,sftUnspecified,sftTimeLog]);
end;

procedure TSQLMyAuthUser.SetProperty(FieldIndex: integer; const Value: variant);
begin
  case FieldIndex of
  0: fID := Value;
  1: fLogonName := Value;
  2: fDisplayName := Value;
  3: fPasswordHashHexa := Value;
  4: fGroupRights := Value;
  5: fData := VariantToBlob(Value);
  6: fLastChange := Value;
  7: fCreatedAt := Value;
  8: fCreated := Iso8601ToDateTime(Value);
  9: fEmail := Value;
  10: fFirstName := Value;
  11: fLastName := Value;
  12: fValidTill := Iso8601ToDateTime(Value);
  13: fConfirm_code := Value;
  14: fpwd_reset_hash := Value;
  15: ftime_expired := Value;
  end;
end;

function TSQLMyAuthUser.GetProperty(FieldIndex: integer): variant;
begin
  case FieldIndex of
  0: result := fID;
  1: result := fLogonName;
  2: result := fDisplayName;
  3: result := fPasswordHashHexa;
  4: result := fGroupRights;
  5: result := BlobToVariant(fData);
  6: result := fLastChange;
  7: result := fCreatedAt;
  8: result := DateTimeToIso8601(fCreated);
  9: result := fEmail;
  10: result := fFirstName;
  11: result := fLastName;
  12: result := DateTimeToIso8601(fValidTill);
  13: result := fConfirm_code;
  14: result := fpwd_reset_hash;
  15: result := ftime_expired;
  end;
end;



{ TSQLSampleRecord }

class function TSQLSampleRecord.ComputeRTTI: TRTTIPropInfos;
begin
  result := TRTTIPropInfos.Create(
    ['Time','Name','Question'],
    [sftModTime,sftUnspecified,sftUnspecified]);
end;

procedure TSQLSampleRecord.SetProperty(FieldIndex: integer; const Value: variant);
begin
  case FieldIndex of
  0: fID := Value;
  1: fTime := Value;
  2: fName := Value;
  3: fQuestion := Value;
  end;
end;

function TSQLSampleRecord.GetProperty(FieldIndex: integer): variant;
begin
  case FieldIndex of
  0: result := fID;
  1: result := fTime;
  2: result := fName;
  3: result := fQuestion;
  end;
end;


function GetModel(aRoot: string): TSQLModel;
begin
  result := TSQLModel.Create([TSQLAuthUser,TSQLAuthGroup,TSQLMyAuthUser,TSQLSampleRecord],aRoot);
end;

procedure GetClient(const aServerAddress, aUserName,aPassword: string;
  onSuccess, onError: TSQLRestEvent; aServerPort: integer; aServerRoot: string;
  aHttps: boolean);
begin
  var client := TSQLRestClientHTTP.Create(aServerAddress,aServerPort,
    GetModel(aServerRoot),true,aHttps); // aOwnModel=true
  client.Connect(
  lambda
    try
      if client.ServerTimeStamp=0 then begin
        if Assigned(onError) then
          onError(client);
        exit;
      end;
      if not client.SetUser(TSQLRestServerAuthenticationDefault,aUserName,aPassword) then begin
        if Assigned(onError) then
          onError(client);
        exit;
      end;
      if Assigned(onSuccess) then
        onSuccess(client);
    except
      if Assigned(onError) then
        onError(client);
    end;
  end,
  onError);
end;


{ TServiceMyService }

constructor TServiceMyService.Create(aClient: TSQLRestClientURI);
begin
  fServiceName := 'MyService';
  fServiceURI := 'MyService';
  fInstanceImplementation := sicShared;
  fContractExpected := 'A9246E85B81B7346';
  inherited Create(aClient);
end;


procedure TServiceMyService.Add(n1: Integer; n2: Integer; 
      onSuccess: procedure(Result: Integer); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'Add',1,
    [n1,n2],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyService._Add(const n1: Integer; const n2: Integer): Integer;
begin
  var res := fClient.CallRemoteServiceSynch(self,'Add',1,
    [n1,n2]);
  Result := res[0];
end;


procedure TServiceMyService.GetSampleRecord(id: TID; 
      onSuccess: procedure(SampleRecord: TSQLSampleRecord; Result: Boolean); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'GetSampleRecord',2,
    [id],
    lambda (res: array of Variant)
      onSuccess(TSQLSampleRecord.CreateFromVariant(res[0]),res[1]);
    end, onError); 
end;

function TServiceMyService._GetSampleRecord(const id: TID; var SampleRecord: TSQLSampleRecord): Boolean;
begin
  var res := fClient.CallRemoteServiceSynch(self,'GetSampleRecord',2,
    [id]);
  SampleRecord := TSQLSampleRecord.CreateFromVariant(res[0]);
  Result := res[1];
end;


procedure TServiceMyService.SignIn(userPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'SignIn',1,
    [userPass],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyService._SignIn(const userPass: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'SignIn',1,
    [userPass]);
  Result := res[0];
end;


procedure TServiceMyService.ChangePassword(newUser: String; oldPass: String; newPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'ChangePassword',1,
    [newUser,oldPass,newPass],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyService._ChangePassword(const newUser: String; const oldPass: String; const newPass: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'ChangePassword',1,
    [newUser,oldPass,newPass]);
  Result := res[0];
end;


procedure TServiceMyService.MostraRec(
      onSuccess: procedure(output: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'MostraRec',1,
    [],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

procedure TServiceMyService._MostraRec(var output: Variant);
begin
  var res := fClient.CallRemoteServiceSynch(self,'MostraRec',1,
    []);
  output := res[0];
end;


procedure TServiceMyService.MostraCustomRec(
      onSuccess: procedure(Result: THttpBody); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'MostraCustomRec',1,
    [],
    lambda (res: array of Variant)
      onSuccess(VariantToHttpBody(res[0]));
    end, onError, true); 
end;

function TServiceMyService._MostraCustomRec(): THttpBody;
begin
  var res := fClient.CallRemoteServiceSynch(self,'MostraCustomRec',1,
    [],true);
  Result := VariantToHttpBody(res[0]);
end;


procedure TServiceMyService.MostraOtherRec(
      onSuccess: procedure(Result: THttpBody); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'MostraOtherRec',1,
    [],
    lambda (res: array of Variant)
      onSuccess(VariantToHttpBody(res[0]));
    end, onError, true); 
end;

function TServiceMyService._MostraOtherRec(): THttpBody;
begin
  var res := fClient.CallRemoteServiceSynch(self,'MostraOtherRec',1,
    [],true);
  Result := VariantToHttpBody(res[0]);
end;



{ TServiceMyServiceFree }

constructor TServiceMyServiceFree.Create(aClient: TSQLRestClientURI);
begin
  fServiceName := 'MyServiceFree';
  fServiceURI := 'MyServiceFree';
  fInstanceImplementation := sicShared;
  fContractExpected := '90724A84210D6F4C';
  inherited Create(aClient);
end;


procedure TServiceMyServiceFree.listar(
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'listar',1,
    [],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._listar(): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'listar',1,
    []);
  Result := res[0];
end;


procedure TServiceMyServiceFree.list(tag: String; tagList: TTagList; 
      onSuccess: procedure(tagList: TTagList; Result: String); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'list',2,
    [tag,TTagList2Variant(tagList)],
    lambda (res: array of Variant)
      onSuccess(Variant2TTagList(res[0]),res[1]);
    end, onError); 
end;

function TServiceMyServiceFree._list(const tag: String; var tagList: TTagList): String;
begin
  var res := fClient.CallRemoteServiceSynch(self,'list',2,
    [tag,TTagList2Variant(tagList)]);
  tagList := Variant2TTagList(res[0]);
  Result := res[1];
end;


procedure TServiceMyServiceFree.decryptAES(cipherText: String; 
      onSuccess: procedure(Result: String); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'decryptAES',1,
    [cipherText],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._decryptAES(const cipherText: String): String;
begin
  var res := fClient.CallRemoteServiceSynch(self,'decryptAES',1,
    [cipherText]);
  Result := res[0];
end;


procedure TServiceMyServiceFree.Echo(str: String; 
      onSuccess: procedure(Result: String); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'Echo',1,
    [str],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._Echo(const str: String): String;
begin
  var res := fClient.CallRemoteServiceSynch(self,'Echo',1,
    [str]);
  Result := res[0];
end;


procedure TServiceMyServiceFree.genIV(
      onSuccess: procedure(Result: String); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'genIV',1,
    [],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._genIV(): String;
begin
  var res := fClient.CallRemoteServiceSynch(self,'genIV',1,
    []);
  Result := res[0];
end;


procedure TServiceMyServiceFree.RegisterCode(token: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'RegisterCode',1,
    [token],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._RegisterCode(const token: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'RegisterCode',1,
    [token]);
  Result := res[0];
end;


procedure TServiceMyServiceFree.RegisterConfirm(token: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'RegisterConfirm',1,
    [token],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._RegisterConfirm(const token: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'RegisterConfirm',1,
    [token]);
  Result := res[0];
end;


procedure TServiceMyServiceFree.SignUp(userPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'SignUp',1,
    [userPass],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._SignUp(const userPass: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'SignUp',1,
    [userPass]);
  Result := res[0];
end;


procedure TServiceMyServiceFree.ChangePassword(newUser: String; oldPass: String; newPass: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'ChangePassword',1,
    [newUser,oldPass,newPass],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._ChangePassword(const newUser: String; const oldPass: String; const newPass: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'ChangePassword',1,
    [newUser,oldPass,newPass]);
  Result := res[0];
end;


procedure TServiceMyServiceFree.ResetCode(userEmail: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'ResetCode',1,
    [userEmail],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._ResetCode(const userEmail: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'ResetCode',1,
    [userEmail]);
  Result := res[0];
end;


procedure TServiceMyServiceFree.ResetPassword(resetCode: String; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'ResetPassword',1,
    [resetCode],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyServiceFree._ResetPassword(const resetCode: String): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'ResetPassword',1,
    [resetCode]);
  Result := res[0];
end;



{ TServiceMyComplexNumber }

constructor TServiceMyComplexNumber.Create(aClient: TSQLRestClientURI);
begin
  fServiceName := 'MyComplexNumber';
  fServiceURI := 'MyComplexNumber';
  fInstanceImplementation := sicShared;
  fContractExpected := '06EA32E4BE9DC69D';
  inherited Create(aClient);
end;


procedure TServiceMyComplexNumber.Assign(aReal: Double; aImaginary: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'Assign',0,
    [aReal,aImaginary],
    lambda (res: array of Variant)
      onSuccess();
    end, onError); 
end;

procedure TServiceMyComplexNumber._Assign(const aReal: Double; const aImaginary: Double);
begin
  var res := fClient.CallRemoteServiceSynch(self,'Assign',0,
    [aReal,aImaginary]);
end;


procedure TServiceMyComplexNumber.GetImaginary(
      onSuccess: procedure(Result: Double); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'GetImaginary',1,
    [],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyComplexNumber._GetImaginary(): Double;
begin
  var res := fClient.CallRemoteServiceSynch(self,'GetImaginary',1,
    []);
  Result := res[0];
end;


procedure TServiceMyComplexNumber.GetReal(
      onSuccess: procedure(Result: Double); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'GetReal',1,
    [],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyComplexNumber._GetReal(): Double;
begin
  var res := fClient.CallRemoteServiceSynch(self,'GetReal',1,
    []);
  Result := res[0];
end;


procedure TServiceMyComplexNumber.SetImaginary(Value: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'SetImaginary',0,
    [Value],
    lambda (res: array of Variant)
      onSuccess();
    end, onError); 
end;

procedure TServiceMyComplexNumber._SetImaginary(const Value: Double);
begin
  var res := fClient.CallRemoteServiceSynch(self,'SetImaginary',0,
    [Value]);
end;


procedure TServiceMyComplexNumber.SetReal(Value: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'SetReal',0,
    [Value],
    lambda (res: array of Variant)
      onSuccess();
    end, onError); 
end;

procedure TServiceMyComplexNumber._SetReal(const Value: Double);
begin
  var res := fClient.CallRemoteServiceSynch(self,'SetReal',0,
    [Value]);
end;


procedure TServiceMyComplexNumber.Add(aReal: Double; aImaginary: Double; 
      onSuccess: procedure(); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'Add',0,
    [aReal,aImaginary],
    lambda (res: array of Variant)
      onSuccess();
    end, onError); 
end;

procedure TServiceMyComplexNumber._Add(const aReal: Double; const aImaginary: Double);
begin
  var res := fClient.CallRemoteServiceSynch(self,'Add',0,
    [aReal,aImaginary]);
end;



{ TServiceMyJogo }

constructor TServiceMyJogo.Create(aClient: TSQLRestClientURI);
begin
  fServiceName := 'MyJogo';
  fServiceURI := 'MyJogo';
  fInstanceImplementation := sicShared;
  fContractExpected := 'D0A9C5F8B65F5142';
  inherited Create(aClient);
end;


procedure TServiceMyJogo.PlayCard(
      onSuccess: procedure(Result: THttpBody); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'PlayCard',1,
    [],
    lambda (res: array of Variant)
      onSuccess(VariantToHttpBody(res[0]));
    end, onError, true); 
end;

function TServiceMyJogo._PlayCard(): THttpBody;
begin
  var res := fClient.CallRemoteServiceSynch(self,'PlayCard',1,
    [],true);
  Result := VariantToHttpBody(res[0]);
end;



{ TServiceMyRemoteSQL }

constructor TServiceMyRemoteSQL.Create(aClient: TSQLRestClientURI);
begin
  fServiceName := 'MyRemoteSQL';
  fServiceURI := 'MyRemoteSQL';
  fInstanceImplementation := sicClientDriven;
  fContractExpected := 'FCA2D262C755BD8B';
  inherited Create(aClient);
end;


procedure TServiceMyRemoteSQL.Connect(aEngine: TMyRemoteSQLEngine; aServerName: String; aDatabaseName: String; aUserID: String; aPassWord: String; 
      onSuccess: procedure(); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'Connect',0,
    [ord(aEngine),aServerName,aDatabaseName,aUserID,aPassWord],
    lambda (res: array of Variant)
      onSuccess();
    end, onError); 
end;

procedure TServiceMyRemoteSQL._Connect(const aEngine: TMyRemoteSQLEngine; const aServerName: String; const aDatabaseName: String; const aUserID: String; const aPassWord: String);
begin
  var res := fClient.CallRemoteServiceSynch(self,'Connect',0,
    [ord(aEngine),aServerName,aDatabaseName,aUserID,aPassWord]);
end;


procedure TServiceMyRemoteSQL.GetTableNames(
      onSuccess: procedure(Result: TRawUTF8DynArray); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'GetTableNames',1,
    [],
    lambda (res: array of Variant)
      onSuccess(Variant2TRawUTF8DynArray(res[0]));
    end, onError); 
end;

function TServiceMyRemoteSQL._GetTableNames(): TRawUTF8DynArray;
begin
  var res := fClient.CallRemoteServiceSynch(self,'GetTableNames',1,
    []);
  Result := Variant2TRawUTF8DynArray(res[0]);
end;


procedure TServiceMyRemoteSQL.Execute(aSQL: String; aExpectResults: Boolean; aExpanded: Boolean; 
      onSuccess: procedure(Result: Variant); onError: TSQLRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self,'Execute',1,
    [aSQL,aExpectResults,aExpanded],
    lambda (res: array of Variant)
      onSuccess(res[0]);
    end, onError); 
end;

function TServiceMyRemoteSQL._Execute(const aSQL: String; const aExpectResults: Boolean; const aExpanded: Boolean): Variant;
begin
  var res := fClient.CallRemoteServiceSynch(self,'Execute',1,
    [aSQL,aExpectResults,aExpanded]);
  Result := res[0];
end;



end.